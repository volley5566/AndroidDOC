# Kotlin 学习资源

* Kotlin 使用 Anko 构建布局的那些事
http://www.glumes.com/kotlin-anko-usage/
* Kotlin 函数魔法 - 双冒号
https://juejin.im/post/59f17e916fb9a0450b659cdb?utm_source=gold_browser_extension
* Kotlin 函数魔法 - lambda 表达式
https://juejin.im/post/59f17f07f265da431d3be7f2?utm_source=gold_browser_extension



## Kotlin知识梳理
* Kotlin 知识梳理(1) - Kotlin 基础
http://www.jianshu.com/p/f9e78d6c54bd
* Kotlin 知识梳理(2) - 函数的定义与调用
http://www.jianshu.com/p/22b92a506db5
* Kotlin 知识梳理(3) - 类、对象和接口
http://www.jianshu.com/p/c2463a6140c5
* Kotlin 知识梳理(4) - 数据类、类委托 及 object 关键字
http://www.jianshu.com/p/5f03cb52a040
* Kotlin 知识梳理(5) - lambda 表达式和成员引用
http://www.jianshu.com/p/c2463a6140c5
* Kotlin 知识梳理(6) - Kotlin 的可空性
http://www.jianshu.com/p/a1a1a79ae4e1

## Kotlin文档资源
* Kotlin官方网站
https://www.kotlincn.net/docs/reference/
* Kotlin for Android 实践 ✔
http://mio4kon.com/2016/08/17/Kotlin%20for%20Android%E5%AE%9E%E8%B7%B5/
* Kotlin 成为 Android 官方支持的一级编程语言，java怎么办
http://www.jianshu.com/p/854b44c74560
* Kotlin编程
http://www.jianshu.com/c/00b33a9fab13
* Android开发技术周报特刊之Kotlin Issue#3
http://androidweekly.cn/android-dev-special-weekly-kotlin-issue-3/
* Kotlin文档中文版本 <br>
http://www.ctolib.com/docs//sfile/kotlin-in-chinese/index.html
* From-Java-To-Kotlin　
http://www.jcodecraeer.com/demo/from-java-to-kotlin/index.html

##
* Kotlin中常见的符号
http://blog.csdn.net/zxc123e/article/details/73368781
* 五分钟学会 Kotlin 语法
http://www.jianshu.com/p/1ea733ea197d
* 从编译层面来了解Kotlin (一)
http://blog.qianlicao.cn/technology/2017/08/31/kotlin-build-sth/
* Kotlin如何成为我们Android开发的主要语言
http://www.infoq.com/cn/articles/how-kotlin-become-our-android-develop-language
## 吴小龙Kotlin系列
1. Kotlin for Android（一）准备工作
http://wuxiaolong.me/2017/05/21/kotlin1/
2. Kotlin for Android（二）基础语法
http://wuxiaolong.me/2017/05/23/kotlin2/
3. Kotlin for Android（三）类和对象
http://wuxiaolong.me/2017/06/01/kotlin3/
4. Kotlin for Android（四）Retrofit + RxJava
http://wuxiaolong.me/2017/06/03/kotlin4/

## Kotlin实战项目  
1. 使用Kotlin撸一款Eyepetizer，学习Kotlin语言 <br> https://github.com/LRH1993/Eyepetizer-in-Kotlin
2. gank.io kotlin实现的干货集中营Android客户端 Kotlin Dagger Databinding Rxjava Retrofit Okhttp3 <br> https://github.com/githubwing/GankClient-Kotlin

3. Mango-完全使用RxKotlin开发的Dribbble Android App 
* https://juejin.im/entry/59912ffef265da3e1e5c02c9/detail?utm_source=gold_browser_extension 
* https://github.com/TonnyL/Mango
* Mango-完全使用RxKotlin开发的Dribbble Android App 
* MVP架构, Material Design设计, 支持DeepLink, 使用了Anko, Flexbox Layout, Glide, Gson, Retrofit, Room等开源库.
*  An Android app for dribbble.com

4. Twobbble Twobbble是一个Android平台的第三方Dribbble客户端，与大多数这类应用一样，他完全基于MaterialDesign设计。而值得一提的是Twobbble完全使用Kotlin开发，并使用了RxJava，Retrofit2，EventBus，Fresco，等多个常用第三方项目，会充分的证明了Kotlin在实际生产中的可靠与Java to Kotlin的过渡之平滑，如果你是初学Kotlin，Twobbble会是一个不错的学习对象。该项目目前实现了Dribbble官方所给出的大多数API，当然还有很多功能未实现，日后也会继续完善，当然如果你有兴趣，欢迎你fork并参与到开发中来。
https://github.com/550609334/Twobbble

5. Kotlin最佳实践
https://idisfkj.github.io/2017/08/21/Kotlin%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/#Delegated-Properties <br>
https://github.com/idisfkj/NewsKotlin

6. 超简单Kotlin版每日一文
http://blog.csdn.net/poorkick/article/details/76431670

7. Kotlin中Retrofit与RxJava的简单封装
https://juejin.im/post/59afa351f265da247f1c8f19?utm_source=gold_browser_extension

8. 使用Kotlin开发Android项目- Kibo
https://juejin.im/entry/59b761b26fb9a00a571d1370?utm_source=gold_browser_extension

## Kotlin应用
* 强大的下拉刷新库，定制任意Header。比官方SwipRefrehLayout处理更加友好(Kotlin、Java双版本)
https://github.com/XiaoQiWen/KRefreshLayout

* KotlinAndroidLib Android开发的扩展
https://github.com/VictorChow/KotlinAndroidLib

* KExtensions 收集 Android 中常用的 Kotlin 扩展函数，代替 Java 工具类和部分基类代码 <br>
https://github.com/zyyoona7/KExtensions



## kotlin全套视频教程
01-课程介绍 <br>
http://www.365yg.com/item/6445599306496868878/  6:05<br>
02_kotlin学习方法 <br>
http://www.365yg.com/item/6445599300020863502/  5:47<br>
03_kotlin选好教练车 <br>
http://www.365yg.com/item/6445599302214484494/  10:54 <br>
04_kotlin你好世界 <br>
http://www.365yg.com/item/6445599304320025102/ 	6:26 <br>
05_kotlin变量与输出 <br>
http://www.365yg.com/item/6445599310758281741/ 	10:32	<br>
06_kotlin二进制基础 <br>
http://www.365yg.com/item/6445599308682101262/ 	4:26	<br>
07_kotlin变量和常量 类型推断 <br>
http://www.365yg.com/item/6445599315044860429/ 	8:52	<br>
08_kotlin变量取值范围 <br>
http://www.365yg.com/item/6445599360783745550/ 	4:59	<br>
09_kotlin函数入门 <br>
http://www.365yg.com/item/6445599317150401037/ 	7:37	<br>
10_kotlin语言boolean <br>
http://www.365yg.com/item/6445599312981262862/ 	7:20	<br>
11_kotlin命令行交互式终端 <br>
http://www.365yg.com/item/6445601227924308494/ 	5:30	<br>
12_kotlin函数加强 <br>
http://www.365yg.com/item/6445601229983711757/ 	13:25	<br>
13_kotlin函数作业讲解 <br>
http://www.365yg.com/item/6445601232097640974/ 	4:54	<br>
14_kotlin字符串模版 <br>
http://www.365yg.com/item/6445601234282873357/ 	7:47	<br>
15_kotlin条件控制if和else <br>
http://www.365yg.com/item/6445601236556186126 	6:11	<br>
16_kotlin字符串比较 <br>
http://www.365yg.com/item/6445751177232515597/ 		<br>
17_kotlin空值处理 <br>
http://www.365yg.com/item/6445752054030795278/ 		<br>
18_kotlin的when表达式 <br>
http://www.365yg.com/item/6445754613458010638/ 		<br>
19_kotlin的loop和Range <br>
http://www.365yg.com/item/6445772006804685326/ 		<br>
20_kotlin的list和map入门 <br>
http://www.365yg.com/item/6445776370827002382/ 		<br>
21_kotlin函数和函数式表达式 <br>
http://www.365yg.com/item/6445777260019450382/ 		<br>
22_kotlin默认参数和具名参数 <br>
http://www.365yg.com/item/6445778515232031245/ 		<br>
23_kotlin字符串和数字之间的转换 <br>
http://www.365yg.com/item/6445779198962303501/ 		<br>
24_kotlin人机交互 <br>
http://www.365yg.com/item/6445780073856369165/ 		<br>
25_kotlin异常处理 <br>
http://www.365yg.com/item/6445781489274585613/ 		<br>
26_kotlin递归 <br>
http://www.365yg.com/item/6445782843170750990/ 		<br>
27_kotlin尾递归优化 <br>
http://www.365yg.com/item/6445785393433412110/ 		<br>
28_kotlin新的篇章idea使用入门 <br>
http://www.365yg.com/item/6445786897338860045/ 		<br>
29_kotlin面向对象入门 <br>
http://www.365yg.com/item/6445788208776086029/ 		<br>
30_kotlin静态属性和动态行为 <br>
http://www.365yg.com/item/6445788927897895438/ 		<br>
31_kotlin面向对象概念入门 <br>
http://www.365yg.com/item/6445789963647713806/ 		<br>
32_kotlin面向对象实战 <br>
http://www.365yg.com/item/6445800737300546061/ 		<br>
33_kotlin面向对象实战-洗衣机升级 <br>
http://www.365yg.com/item/6445795869391323661/ 		<br>
34_kotlin面向对象实战-封装 <br>
http://www.365yg.com/item/6445796836392305166/ 		<br>
35_kotlin面向对象-继承(open和override) <br>
http://www.365yg.com/item/6445798149792465422/ 		<br>
36_kotlin抽象类和继承 <br>
http://www.365yg.com/item/6445799199903580686/ 		<br>
37_kotlin面向对象-多态 <br>
http://www.365yg.com/item/6445799900012610061/ 		<br>
38_kotlin面向对象-抽象类和接口 <br>
http://www.365yg.com/item/6445803237701321230/ 		<br>
39_kotlin面向对象-委托和代理 <br>
http://www.365yg.com/item/6445804765518496269/ 		<br>
40_kotlin面向对象-单例模式 <br>
http://www.365yg.com/item/6445805583856566797/ 		<br>
41_kotlin面向对象-枚举 <br>
http://www.365yg.com/item/6445806126301708814/ 		<br>
42_kotlin面向对象-密封类 <br>
http://www.365yg.com/item/6445807030564291085/ 		<br>

# 2. Kotlin基本语法

## 变量
* 不可变变量：val修饰

		val s= "Sample" //自动推断出字符串
		val i= 23//整型，立即赋值

* 也可以指定类型：
  
		val s:Stirng = "Sample" //指定String 类型
	    val activity:Context = this
	    
* 可变变量：var修饰 <br>
  
		varx =5x +=1//自动推断出 int 类型

**不管变量时var还是val都要初始化值，这点保证了空安全**

## 基本数据类型
### 1.数字类型：
	
数字类型 | 
------------ | 
Double | 
Float | 
Long | 
Int | 
Short | 
Byte | 

* Kotlin没有隐式拓宽转换，如java当中的int可以饮食转换为long,必须要显示类型转换

		val a:Double = 5.2
		val b:Int = a.toInt()//显示转， b等于5
		
		val c:Float = 5.2F
		val d:Int = c.toInt()//d等于5


* 显示类型转换的方法：
		
		toByte():Byte
		toShort():Short
		toInt():Int
		toLong():Long
		toFloat():Float
		toDoubel():Double
		toChar():Char
		
### 2.字符串
* 使用Char类型表示

		val e:Char = 'q'


### 3.布尔
* 使用Boolean类型表示：

		val f:Boolean = true
		
		
### 4.字符串
* 使用String 表示

		val g:String = "Hello World"


### 5.字符串模板
* 字符串模板，可以包含一些小段代码，会把求值结果合并到字符串中
* 模板表达式以 美元符号（$）开头

		val h = "me"
		val j = "it is $h"


* 模板中的任意表达式，用大括号：
	
		val k = "h length is ${h.length}"//h length is 2
		

### 6.数组
* 使用Array类来创建和操作数组，它定义了get和set函数，size属性，及其他的成员函数

* 使用库函数arrayOf()来创建一个数组并传递元素值给他
		
		arrayOf(1,2,3)
		array[1,2,3]//以上语句创建的
		
* []可以用于访问数组元素，实际上[]被惊醒了操作符的重载，调用的是Array类的get和set方法

* 库函数arrayOfNulls()可以用于创建一个指定大小，元素都为空的数组

		//使用装箱操作
		val arr1 =arrayOf(1,2,3)	
		
		//原生类型数组，还有BtyeArray,ShorArray等
		val arr2:IntArray = IntArrayOf(1,2,3)
		
		//直接指定长度
		val arr3 = arrayOfNulls<Int>(5)
		
		//长度为0的空数组
		val arr3 = emptyArray<Int>()
		
		//访问数组元素
		val arr4  = arrayOf(1,2,3)
		println(arr4[1])//输出“2”,建议用这个方法
		println(arr4.get(1))//输出“2”
		
		//修改元素
		arr4[1]=10
		println(arr4[1])//输出“10”
		
		//遍历数组
		for(arr in arr4){
			println(arr)
		}
		
		//遍历数组下标
		for(arr in arr4.indices){
			println(arr)
		}
		
		
## 控制流
		
### 1.if表达式
* Kotlin里可以作为一个表达式，返回一个值
	
		val l =4
		val m = 5
		//作为表达式
		val n = if(l>m)else m

### 2.when表达式
* when取代 Java switch操作符

		val o = 3
		when(o){
			1-> print("o == 1")
			2-> print("o == 2")
		else->{
			print("o == 3")
		}
		}
				
### 3.For循环

		val arr5 = arrayOf(1,2,3,4,5)
		for(arr in arr5){
			println(arr)
		}
		
### 4.while循环
* 和java一样


## 函数声明
* 使用fun关键字声明

			//返回类型lnt
			fun sum(p:lnt,q:lnt):lnt{
				return p+q
			}
			
			//表达式作为返回值
			fun sum(p:Int,q:Int)= p+q
			
			//函数返回无意义的值，相当于JAVA里的void
			fun sum(p:Int,q:Int):Unit{
			}
			
			//Unit 返回类型可以省略
			fun sum(p:Int,q:Int){
			}



## 空安全
* 问号表示该变量可以为空

			override fun onCreate(savedInstanceState:Bundle?){
				super.onCreate(savedInstanceState)
				setContentView(R.layout.activity_main)
			}


## 定义类
* 使用class关键字声明类

			//冒号表示继承
  			class MainAcitvity:AppCompatActivity(){
  			}
	
***********


## 类

* 使用 class 关键字声明类。
* 类声明由类名、类头（指定其类型参数、主构造函数等）和由大括号包围的类体构成。
* 一个类可以有一个主构造函数和一个或多个次构造函数。

### 1.主构造函数

		//类名:WeatherinfoModel
		//主构造函数:constructor(val weatherinfo: WeatherinfoBean)
		class WeatherinfoModel public constructor(val weatherinfo: WeatherinfoBean)   {
    //类体
    init {
        //主构造函数不能包含任何的代码，
        //初始化的代码可以放到 init 块中
    }
	}  
	

如果主构造函数没有任何注解或者可见性修饰符（private、 protected、 internal 和 public），可以省略这个 constructor 关键字。


### 2.次构造函数

类也可以声明前缀有 constructor的次构造函数

		
		class Person {
				constructor(parent: Person){
					parent.children.add(this);
				}
		}  
		
		
### 3.创建类的实例

Kotlin并没有new关键字，简单粗暴：

		var person = Person()
		


****************
## 继承

* 声明一个显示的父类:

		open class Base {
			open fun v(){
			}
		}
		
* 子类冒号继承，override 标注在子类中覆盖：

		class Child: Base {
			ovrride fun v(){
			}
		}
		
* 如果累没有主构造函数，那么每次构造函数必须使用使用 super 关键字初始化其基类型：

		
		class MyView :View {
			constructor(ctx: Context):super(ctx)
    	  constructor(ctx: Context, attrs:    AttributeSet) : super(ctx, attrs)
		}
		
		
****************		
## 泛型

* 泛型类

		class Application<M>(m:M){}
		
	

* 泛型函数
  
类型参数要放在函数名称之前：  

		fun <M> addSubscription(observable: Observable<M>, subscriber: Subscriber<M>) {
       //.........
		}
		
		
	
	
****************	
## 抽象类

		abstract class ApiCallback<M> {
    		abstract fun onSuccess(model: M)
    		abstract fun onFailure(msg: String?)
    		abstract fun onFinish()
		}
		
1、抽象方法必须为 public 或者 protected，缺省情况下默认为 public；<br>
2、抽象类不能用来创建对象；<br>
3、如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为 abstract 类。如果抽象类中含有抽象属性，再实现子类中必须将抽象属性初始化，除非子类也为抽象类。

### 抽象方法

1、抽象方法必须用 abstract 关键字进行修饰；<br>
2、抽象方法默认被 open 修饰，可以不用手动添加 open；<br>
3、抽象方法没有具体的实现；<br>
4、含有抽象方法的类成为抽象类，必须由 abtract 关键字修饰。

### 抽象属性

抽象属性就是在 var 或 val 前被 abstract 修饰。


****************
## 嵌套类

* 类里面可以嵌套在其他类：
		
		class A {
    		val a: String = "a"

    		class B {
        		val b: String = "b"
    		}
		}

访问：

		val a = A.B().b//a输出为“b”
		
* 如果想让类 B 能访问类 A 的成员，可以加 inner 标记：

		class A {
    		val a: String = "a"

    		inner class B {
       		 val b: String = a
		    }
	    }
	    
访问：

		val a = A().B().b//a输出为“a”
		
************
## 对象

有时候，我们需要创建一个对某个类做轻微改动的类的对象，而不是为之显式声明新的子类。

### 1.对象表达式

抽象类不能用来创建对象，可以创建一个继承自某个（或某些）类型的匿名内部类的对象:

		ApiClient.retrofit().loadData("101190201"), object : ApiCallback<WeatherinfoModel>() {
            override fun onSuccess(model: WeatherinfoModel) {
                //……
            }

            override fun onFailure(msg: String?) {
                //……
            }

            override fun onFinish() {
                //……
            }}
            
            
### 2.对象声明

* 单例模式
在 object 关键字后跟一个名称，声明单例模式：


		object ApiClient {
    	  fun retrofit(): ApiStores {
    	  //……
        		return retrofit.create(ApiStores::class.java)
       	}
		}

引用该对象：

		ApiClient.retrofit()

* 伴生对象

使用 companion 关键字标记：

		class ApiStores {
    			companion object A {
        		//baseUrl
        		val API_SERVER_URL = "http://				www.weather.com.cn/"
   			 }
		}
		
这样就能直接访问该伴生对象的成员：
		
		val url = ApiStores.API_SERVER_URL
		
可以省略伴生对象的名称 A，伴生对象也适合接口。


## 数据类
数据类提供了访问它们属性 getter 和 setter，toString()等：

		data class WeatherinfoModel constructor(val weatherinfo: WeatherinfoBean) {
    
    			data class WeatherinfoBean(
            		val city: String,
            		val cityid: String
    			)
		}
		
数据类必须满足以下要求：

1、主构造函数需要至少有一个参数；<br>
2、主构造函数的所有参数需要标记为 val 或 var；<br>
3、数据类不能是抽象、开放、密封或者内部的；<br>
4、在 1.1 之前，数据类只能实现接口。

## 复制
在很多情况下，我们只需要改变一个对象某些属性，其余部分保持不变，这里可以用到数据类的 copy，以上面的 WeatherinfoModel 为例，Retrofit 请求成功，我有个回调：


		override fun onSuccess(model: WeatherinfoModel) {
    Log.d("wxl",model.toString())//输出“WeatherinfoModel(weatherinfo=WeatherinfoBean(city=无锡, cityid=101190201))”
    Log.d("wxl", "city=" + model.weatherinfo.city + ",cityid=" + model.weatherinfo.cityid)//输出“city=无锡,cityid=101190201”
    val weatherinfoBean = model.weatherinfo.copy(city = "上海")
    val weatherinfoModel = WeatherinfoModel(weatherinfoBean)
    Log.d("wxl", "city1=" + 		weatherinfoModel.weatherinfo.city + ",cityid1=" + weatherinfoModel.weatherinfo.cityid)//输出“city1=上海,cityid1=101190201”
		}

## 委托
所谓委托模式 ，就是为其他对象提供一种代理以控制对这个对象的访问，在 Java 开发过程中，是继承模式之外的很好的解决问题的方案。

		interface Base {
   			 fun print()
		}

		class A(val a: Int) : Base {
    		override fun print() {
        		Log.d("wxl", "a=" + a)
    		}
		}

		class B (val base: Base):Base by base

调用：

		val a = A(1)
		Log.d("wxl", "a=" + B(a).print())
		
类 B 居然能调用类 A 方法，关键字 by 表示 base 将会在 B 中内部存储, 并且编译器将生成转发给 base 的所有 Base 的方法。




## DSL 领域特定语言

## 协程 没有异步能力
* 协程与线程的区别
1. 协程：应用层面的  协助式  挂起 只是占用一块内存
2. 线程：系统层面的  抢占式  

* 协程的优点
1. 写异步代码要想同步代码一样直观
2. 简化异步代码的异常处理
3. 轻量级并发方案

* Kotlin 对协程的支持
1. 编译器对suspend函数的编译支持 表示函数会对挂起
2. 标准库的基本API支持
3. kotlinx.coroutine应用级支持  （使用）


* 线程阻塞 - 协程挂起：协程通过将复杂性放入库来简化异步编程













